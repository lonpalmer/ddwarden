/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
package com.lon.ipc.pipe

import com.fasterxml.jackson.databind.ObjectMapper
import com.lon.App
import com.lon.ipc.IDdwIpc
import com.lon.ipc.IDdwMessage
import com.lon.ipc.message.KeepAliveAckMessage
import com.lon.ipc.message.KeepAliveMessage
import com.lon.ipc.StreamingMessageCoder
import spock.lang.Ignore
import spock.lang.IgnoreIf
import spock.lang.Shared
import spock.lang.Specification


import java.time.Duration
import java.time.Instant
import java.util.concurrent.BlockingQueue
import java.util.concurrent.LinkedBlockingQueue

@Ignore
class PipeIpcTest extends Specification {

    @Shared
    App app

    def setupSpec() {
        app = DaggerAppPipeTestComponent.create().app()
        Thread.ofPlatform().start(()->app.start())
    }

    @Ignore
    @SuppressWarnings('GroovyInfiniteLoopStatement')
    //@IgnoreIf({ os.windows })
    def "Test the named pipe connection in the app"() {
        given:
        def txPipeName = "/tmp/" + IDdwIpc.DDW_IPC_PIPE_NAME + "_RX"
        def rxPipeName = "/tmp/" + IDdwIpc.DDW_IPC_PIPE_NAME + "_TX"
        def iterations = 5
        def messageCoder = new StreamingMessageCoder(new ObjectMapper())

        final BlockingQueue<IDdwMessage> receivedMessages = new LinkedBlockingQueue<>()

        if (new File(rxPipeName).exists()) {
            new File(rxPipeName).delete()
        }

        new ProcessBuilder().command("mkfifo", rxPipeName).start().waitFor()

        def rcvThread = Thread.ofPlatform().start(()->{
            var inStream = new FileInputStream(rxPipeName)

            while(true) {
                int available = inStream.available()
                if(available == 0) {
                    Thread.yield()
                } else {
                    var rxMsg = messageCoder.decode(inStream.read())
                    rxMsg.ifPresent(receivedMessages::add)
                }
            }
        })

        var outStream = new FileOutputStream(txPipeName)
        def msg = new KeepAliveMessage()

        when:
        for(int i in 1..iterations){
            outStream.write(messageCoder.encode(msg))
        }

        Instant start = Instant.now()
        while(receivedMessages.size() < iterations && Duration.between(start, Instant.now()).toSeconds() < 3) {
            Thread.yield()
        }
        println("Total message time: " + Duration.between(start, Instant.now()).toMillis() + "ms")

        rcvThread.interrupt()

        then:
        receivedMessages.size() == iterations
        receivedMessages.stream().allMatch(rcvMsg -> rcvMsg instanceof KeepAliveAckMessage)

    }


}
